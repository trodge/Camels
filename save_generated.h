// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SAVE_SAVE_H_
#define FLATBUFFERS_GENERATED_SAVE_SAVE_H_

#include "flatbuffers/flatbuffers.h"

namespace Save {

struct PerishCounter;

struct CombatStat;

struct MaterialInfo;

struct Material;

struct Good;

struct Property;

struct AI;

struct Traveler;

struct Business;

struct Town;

struct Color;

struct Nation;

struct Game;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PerishCounter FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t time_;
  int32_t padding0__;
  double amount_;

 public:
  PerishCounter() {
    memset(static_cast<void *>(this), 0, sizeof(PerishCounter));
  }
  PerishCounter(int32_t _time, double _amount)
      : time_(flatbuffers::EndianScalar(_time)),
        padding0__(0),
        amount_(flatbuffers::EndianScalar(_amount)) {
    (void)padding0__;
  }
  int32_t time() const {
    return flatbuffers::EndianScalar(time_);
  }
  double amount() const {
    return flatbuffers::EndianScalar(amount_);
  }
};
FLATBUFFERS_STRUCT_END(PerishCounter, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CombatStat FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t statId_;
  uint32_t partId_;
  uint32_t attack_;
  uint32_t type_;
  uint32_t speed_;
  uint32_t bashDefense_;
  uint32_t cutDefense_;
  uint32_t stabDefense_;

 public:
  CombatStat() {
    memset(static_cast<void *>(this), 0, sizeof(CombatStat));
  }
  CombatStat(uint32_t _statId, uint32_t _partId, uint32_t _attack, uint32_t _type, uint32_t _speed, uint32_t _bashDefense, uint32_t _cutDefense, uint32_t _stabDefense)
      : statId_(flatbuffers::EndianScalar(_statId)),
        partId_(flatbuffers::EndianScalar(_partId)),
        attack_(flatbuffers::EndianScalar(_attack)),
        type_(flatbuffers::EndianScalar(_type)),
        speed_(flatbuffers::EndianScalar(_speed)),
        bashDefense_(flatbuffers::EndianScalar(_bashDefense)),
        cutDefense_(flatbuffers::EndianScalar(_cutDefense)),
        stabDefense_(flatbuffers::EndianScalar(_stabDefense)) {
  }
  uint32_t statId() const {
    return flatbuffers::EndianScalar(statId_);
  }
  uint32_t partId() const {
    return flatbuffers::EndianScalar(partId_);
  }
  uint32_t attack() const {
    return flatbuffers::EndianScalar(attack_);
  }
  uint32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  uint32_t speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  uint32_t bashDefense() const {
    return flatbuffers::EndianScalar(bashDefense_);
  }
  uint32_t cutDefense() const {
    return flatbuffers::EndianScalar(cutDefense_);
  }
  uint32_t stabDefense() const {
    return flatbuffers::EndianScalar(stabDefense_);
  }
};
FLATBUFFERS_STRUCT_END(CombatStat, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MaterialInfo FLATBUFFERS_FINAL_CLASS {
 private:
  double limitFactor_;
  double minPrice_;
  double maxPrice_;
  double value_;
  double buy_;
  double sell_;

 public:
  MaterialInfo() {
    memset(static_cast<void *>(this), 0, sizeof(MaterialInfo));
  }
  MaterialInfo(double _limitFactor, double _minPrice, double _maxPrice, double _value, double _buy, double _sell)
      : limitFactor_(flatbuffers::EndianScalar(_limitFactor)),
        minPrice_(flatbuffers::EndianScalar(_minPrice)),
        maxPrice_(flatbuffers::EndianScalar(_maxPrice)),
        value_(flatbuffers::EndianScalar(_value)),
        buy_(flatbuffers::EndianScalar(_buy)),
        sell_(flatbuffers::EndianScalar(_sell)) {
  }
  double limitFactor() const {
    return flatbuffers::EndianScalar(limitFactor_);
  }
  double minPrice() const {
    return flatbuffers::EndianScalar(minPrice_);
  }
  double maxPrice() const {
    return flatbuffers::EndianScalar(maxPrice_);
  }
  double value() const {
    return flatbuffers::EndianScalar(value_);
  }
  double buy() const {
    return flatbuffers::EndianScalar(buy_);
  }
  double sell() const {
    return flatbuffers::EndianScalar(sell_);
  }
};
FLATBUFFERS_STRUCT_END(MaterialInfo, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  Color() {
    memset(static_cast<void *>(this), 0, sizeof(Color));
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 4);

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_AMOUNT = 8,
    VT_CONSUMPTION = 10,
    VT_DEMANDSLOPE = 12,
    VT_DEMANDINTERCEPT = 14,
    VT_PERISHCOUNTERS = 16,
    VT_COMBATSTATS = 18,
    VT_LIMITFACTOR = 20
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  double consumption() const {
    return GetField<double>(VT_CONSUMPTION, 0.0);
  }
  double demandSlope() const {
    return GetField<double>(VT_DEMANDSLOPE, 0.0);
  }
  double demandIntercept() const {
    return GetField<double>(VT_DEMANDINTERCEPT, 0.0);
  }
  const flatbuffers::Vector<const PerishCounter *> *perishCounters() const {
    return GetPointer<const flatbuffers::Vector<const PerishCounter *> *>(VT_PERISHCOUNTERS);
  }
  const flatbuffers::Vector<const CombatStat *> *combatStats() const {
    return GetPointer<const flatbuffers::Vector<const CombatStat *> *>(VT_COMBATSTATS);
  }
  double limitFactor() const {
    return GetField<double>(VT_LIMITFACTOR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyField<double>(verifier, VT_CONSUMPTION) &&
           VerifyField<double>(verifier, VT_DEMANDSLOPE) &&
           VerifyField<double>(verifier, VT_DEMANDINTERCEPT) &&
           VerifyOffset(verifier, VT_PERISHCOUNTERS) &&
           verifier.VerifyVector(perishCounters()) &&
           VerifyOffset(verifier, VT_COMBATSTATS) &&
           verifier.VerifyVector(combatStats()) &&
           VerifyField<double>(verifier, VT_LIMITFACTOR) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Material::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Material::VT_NAME, name);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(Material::VT_AMOUNT, amount, 0.0);
  }
  void add_consumption(double consumption) {
    fbb_.AddElement<double>(Material::VT_CONSUMPTION, consumption, 0.0);
  }
  void add_demandSlope(double demandSlope) {
    fbb_.AddElement<double>(Material::VT_DEMANDSLOPE, demandSlope, 0.0);
  }
  void add_demandIntercept(double demandIntercept) {
    fbb_.AddElement<double>(Material::VT_DEMANDINTERCEPT, demandIntercept, 0.0);
  }
  void add_perishCounters(flatbuffers::Offset<flatbuffers::Vector<const PerishCounter *>> perishCounters) {
    fbb_.AddOffset(Material::VT_PERISHCOUNTERS, perishCounters);
  }
  void add_combatStats(flatbuffers::Offset<flatbuffers::Vector<const CombatStat *>> combatStats) {
    fbb_.AddOffset(Material::VT_COMBATSTATS, combatStats);
  }
  void add_limitFactor(double limitFactor) {
    fbb_.AddElement<double>(Material::VT_LIMITFACTOR, limitFactor, 0.0);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double amount = 0.0,
    double consumption = 0.0,
    double demandSlope = 0.0,
    double demandIntercept = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<const PerishCounter *>> perishCounters = 0,
    flatbuffers::Offset<flatbuffers::Vector<const CombatStat *>> combatStats = 0,
    double limitFactor = 0.0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_limitFactor(limitFactor);
  builder_.add_demandIntercept(demandIntercept);
  builder_.add_demandSlope(demandSlope);
  builder_.add_consumption(consumption);
  builder_.add_amount(amount);
  builder_.add_combatStats(combatStats);
  builder_.add_perishCounters(perishCounters);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Material> CreateMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    double amount = 0.0,
    double consumption = 0.0,
    double demandSlope = 0.0,
    double demandIntercept = 0.0,
    const std::vector<PerishCounter> *perishCounters = nullptr,
    const std::vector<CombatStat> *combatStats = nullptr,
    double limitFactor = 0.0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto perishCounters__ = perishCounters ? _fbb.CreateVectorOfStructs<PerishCounter>(*perishCounters) : 0;
  auto combatStats__ = combatStats ? _fbb.CreateVectorOfStructs<CombatStat>(*combatStats) : 0;
  return Save::CreateMaterial(
      _fbb,
      id,
      name__,
      amount,
      consumption,
      demandSlope,
      demandIntercept,
      perishCounters__,
      combatStats__,
      limitFactor);
}

struct Good FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_AMOUNT = 8,
    VT_MATERIALS = 10,
    VT_PERISH = 12,
    VT_CARRY = 14,
    VT_MEASURE = 16,
    VT_SHOOTS = 18
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Material>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Material>> *>(VT_MATERIALS);
  }
  double perish() const {
    return GetField<double>(VT_PERISH, 0.0);
  }
  double carry() const {
    return GetField<double>(VT_CARRY, 0.0);
  }
  const flatbuffers::String *measure() const {
    return GetPointer<const flatbuffers::String *>(VT_MEASURE);
  }
  uint32_t shoots() const {
    return GetField<uint32_t>(VT_SHOOTS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<double>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyField<double>(verifier, VT_PERISH) &&
           VerifyField<double>(verifier, VT_CARRY) &&
           VerifyOffset(verifier, VT_MEASURE) &&
           verifier.VerifyString(measure()) &&
           VerifyField<uint32_t>(verifier, VT_SHOOTS) &&
           verifier.EndTable();
  }
};

struct GoodBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Good::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Good::VT_NAME, name);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(Good::VT_AMOUNT, amount, 0.0);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials) {
    fbb_.AddOffset(Good::VT_MATERIALS, materials);
  }
  void add_perish(double perish) {
    fbb_.AddElement<double>(Good::VT_PERISH, perish, 0.0);
  }
  void add_carry(double carry) {
    fbb_.AddElement<double>(Good::VT_CARRY, carry, 0.0);
  }
  void add_measure(flatbuffers::Offset<flatbuffers::String> measure) {
    fbb_.AddOffset(Good::VT_MEASURE, measure);
  }
  void add_shoots(uint32_t shoots) {
    fbb_.AddElement<uint32_t>(Good::VT_SHOOTS, shoots, 0);
  }
  explicit GoodBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GoodBuilder &operator=(const GoodBuilder &);
  flatbuffers::Offset<Good> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Good>(end);
    return o;
  }
};

inline flatbuffers::Offset<Good> CreateGood(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double amount = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials = 0,
    double perish = 0.0,
    double carry = 0.0,
    flatbuffers::Offset<flatbuffers::String> measure = 0,
    uint32_t shoots = 0) {
  GoodBuilder builder_(_fbb);
  builder_.add_carry(carry);
  builder_.add_perish(perish);
  builder_.add_amount(amount);
  builder_.add_shoots(shoots);
  builder_.add_measure(measure);
  builder_.add_materials(materials);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Good> CreateGoodDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    double amount = 0.0,
    const std::vector<flatbuffers::Offset<Material>> *materials = nullptr,
    double perish = 0.0,
    double carry = 0.0,
    const char *measure = nullptr,
    uint32_t shoots = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto materials__ = materials ? _fbb.CreateVector<flatbuffers::Offset<Material>>(*materials) : 0;
  auto measure__ = measure ? _fbb.CreateString(measure) : 0;
  return Save::CreateGood(
      _fbb,
      id,
      name__,
      amount,
      materials__,
      perish,
      carry,
      measure__,
      shoots);
}

struct Property FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE = 4,
    VT_BUSINESSES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *storage() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_STORAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Business>> *businesses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Business>> *>(VT_BUSINESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STORAGE) &&
           verifier.VerifyVector(storage()) &&
           verifier.VerifyVectorOfTables(storage()) &&
           VerifyOffset(verifier, VT_BUSINESSES) &&
           verifier.VerifyVector(businesses()) &&
           verifier.VerifyVectorOfTables(businesses()) &&
           verifier.EndTable();
  }
};

struct PropertyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_storage(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> storage) {
    fbb_.AddOffset(Property::VT_STORAGE, storage);
  }
  void add_businesses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses) {
    fbb_.AddOffset(Property::VT_BUSINESSES, businesses);
  }
  explicit PropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PropertyBuilder &operator=(const PropertyBuilder &);
  flatbuffers::Offset<Property> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Property>(end);
    return o;
  }
};

inline flatbuffers::Offset<Property> CreateProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> storage = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses = 0) {
  PropertyBuilder builder_(_fbb);
  builder_.add_businesses(businesses);
  builder_.add_storage(storage);
  return builder_.Finish();
}

inline flatbuffers::Offset<Property> CreatePropertyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Good>> *storage = nullptr,
    const std::vector<flatbuffers::Offset<Business>> *businesses = nullptr) {
  auto storage__ = storage ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*storage) : 0;
  auto businesses__ = businesses ? _fbb.CreateVector<flatbuffers::Offset<Business>>(*businesses) : 0;
  return Save::CreateProperty(
      _fbb,
      storage__,
      businesses__);
}

struct AI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DECISIONCOUNTER = 4,
    VT_DECISIONCRITERIA = 6,
    VT_MATERIALINFO = 8
  };
  int32_t decisionCounter() const {
    return GetField<int32_t>(VT_DECISIONCOUNTER, 0);
  }
  const flatbuffers::Vector<double> *decisionCriteria() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DECISIONCRITERIA);
  }
  const flatbuffers::Vector<const MaterialInfo *> *materialInfo() const {
    return GetPointer<const flatbuffers::Vector<const MaterialInfo *> *>(VT_MATERIALINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DECISIONCOUNTER) &&
           VerifyOffset(verifier, VT_DECISIONCRITERIA) &&
           verifier.VerifyVector(decisionCriteria()) &&
           VerifyOffset(verifier, VT_MATERIALINFO) &&
           verifier.VerifyVector(materialInfo()) &&
           verifier.EndTable();
  }
};

struct AIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_decisionCounter(int32_t decisionCounter) {
    fbb_.AddElement<int32_t>(AI::VT_DECISIONCOUNTER, decisionCounter, 0);
  }
  void add_decisionCriteria(flatbuffers::Offset<flatbuffers::Vector<double>> decisionCriteria) {
    fbb_.AddOffset(AI::VT_DECISIONCRITERIA, decisionCriteria);
  }
  void add_materialInfo(flatbuffers::Offset<flatbuffers::Vector<const MaterialInfo *>> materialInfo) {
    fbb_.AddOffset(AI::VT_MATERIALINFO, materialInfo);
  }
  explicit AIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AIBuilder &operator=(const AIBuilder &);
  flatbuffers::Offset<AI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AI>(end);
    return o;
  }
};

inline flatbuffers::Offset<AI> CreateAI(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t decisionCounter = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> decisionCriteria = 0,
    flatbuffers::Offset<flatbuffers::Vector<const MaterialInfo *>> materialInfo = 0) {
  AIBuilder builder_(_fbb);
  builder_.add_materialInfo(materialInfo);
  builder_.add_decisionCriteria(decisionCriteria);
  builder_.add_decisionCounter(decisionCounter);
  return builder_.Finish();
}

inline flatbuffers::Offset<AI> CreateAIDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t decisionCounter = 0,
    const std::vector<double> *decisionCriteria = nullptr,
    const std::vector<MaterialInfo> *materialInfo = nullptr) {
  auto decisionCriteria__ = decisionCriteria ? _fbb.CreateVector<double>(*decisionCriteria) : 0;
  auto materialInfo__ = materialInfo ? _fbb.CreateVectorOfStructs<MaterialInfo>(*materialInfo) : 0;
  return Save::CreateAI(
      _fbb,
      decisionCounter,
      decisionCriteria__,
      materialInfo__);
}

struct Traveler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TOTOWN = 6,
    VT_FROMTOWN = 8,
    VT_NATION = 10,
    VT_LOG = 12,
    VT_LONGITUDE = 14,
    VT_LATITUDE = 16,
    VT_GOODS = 18,
    VT_PROPERTIES = 20,
    VT_STATS = 22,
    VT_PARTS = 24,
    VT_EQUIPMENT = 26,
    VT_AI = 28,
    VT_MOVING = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t toTown() const {
    return GetField<uint32_t>(VT_TOTOWN, 0);
  }
  uint32_t fromTown() const {
    return GetField<uint32_t>(VT_FROMTOWN, 0);
  }
  uint32_t nation() const {
    return GetField<uint32_t>(VT_NATION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *log() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOG);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *goods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_GOODS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Property>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Property>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<uint32_t> *stats() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STATS);
  }
  const flatbuffers::Vector<uint32_t> *parts() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *equipment() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_EQUIPMENT);
  }
  const AI *ai() const {
    return GetPointer<const AI *>(VT_AI);
  }
  bool moving() const {
    return GetField<uint8_t>(VT_MOVING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TOTOWN) &&
           VerifyField<uint32_t>(verifier, VT_FROMTOWN) &&
           VerifyField<uint32_t>(verifier, VT_NATION) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyVector(log()) &&
           verifier.VerifyVectorOfStrings(log()) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyOffset(verifier, VT_GOODS) &&
           verifier.VerifyVector(goods()) &&
           verifier.VerifyVectorOfTables(goods()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_STATS) &&
           verifier.VerifyVector(stats()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           VerifyOffset(verifier, VT_EQUIPMENT) &&
           verifier.VerifyVector(equipment()) &&
           verifier.VerifyVectorOfTables(equipment()) &&
           VerifyOffset(verifier, VT_AI) &&
           verifier.VerifyTable(ai()) &&
           VerifyField<uint8_t>(verifier, VT_MOVING) &&
           verifier.EndTable();
  }
};

struct TravelerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Traveler::VT_NAME, name);
  }
  void add_toTown(uint32_t toTown) {
    fbb_.AddElement<uint32_t>(Traveler::VT_TOTOWN, toTown, 0);
  }
  void add_fromTown(uint32_t fromTown) {
    fbb_.AddElement<uint32_t>(Traveler::VT_FROMTOWN, fromTown, 0);
  }
  void add_nation(uint32_t nation) {
    fbb_.AddElement<uint32_t>(Traveler::VT_NATION, nation, 0);
  }
  void add_log(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> log) {
    fbb_.AddOffset(Traveler::VT_LOG, log);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(Traveler::VT_LONGITUDE, longitude, 0.0);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(Traveler::VT_LATITUDE, latitude, 0.0);
  }
  void add_goods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods) {
    fbb_.AddOffset(Traveler::VT_GOODS, goods);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Property>>> properties) {
    fbb_.AddOffset(Traveler::VT_PROPERTIES, properties);
  }
  void add_stats(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stats) {
    fbb_.AddOffset(Traveler::VT_STATS, stats);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> parts) {
    fbb_.AddOffset(Traveler::VT_PARTS, parts);
  }
  void add_equipment(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> equipment) {
    fbb_.AddOffset(Traveler::VT_EQUIPMENT, equipment);
  }
  void add_ai(flatbuffers::Offset<AI> ai) {
    fbb_.AddOffset(Traveler::VT_AI, ai);
  }
  void add_moving(bool moving) {
    fbb_.AddElement<uint8_t>(Traveler::VT_MOVING, static_cast<uint8_t>(moving), 0);
  }
  explicit TravelerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TravelerBuilder &operator=(const TravelerBuilder &);
  flatbuffers::Offset<Traveler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Traveler>(end);
    return o;
  }
};

inline flatbuffers::Offset<Traveler> CreateTraveler(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t toTown = 0,
    uint32_t fromTown = 0,
    uint32_t nation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> log = 0,
    double longitude = 0.0,
    double latitude = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Property>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> stats = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> equipment = 0,
    flatbuffers::Offset<AI> ai = 0,
    bool moving = false) {
  TravelerBuilder builder_(_fbb);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  builder_.add_ai(ai);
  builder_.add_equipment(equipment);
  builder_.add_parts(parts);
  builder_.add_stats(stats);
  builder_.add_properties(properties);
  builder_.add_goods(goods);
  builder_.add_log(log);
  builder_.add_nation(nation);
  builder_.add_fromTown(fromTown);
  builder_.add_toTown(toTown);
  builder_.add_name(name);
  builder_.add_moving(moving);
  return builder_.Finish();
}

inline flatbuffers::Offset<Traveler> CreateTravelerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t toTown = 0,
    uint32_t fromTown = 0,
    uint32_t nation = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *log = nullptr,
    double longitude = 0.0,
    double latitude = 0.0,
    const std::vector<flatbuffers::Offset<Good>> *goods = nullptr,
    const std::vector<flatbuffers::Offset<Property>> *properties = nullptr,
    const std::vector<uint32_t> *stats = nullptr,
    const std::vector<uint32_t> *parts = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *equipment = nullptr,
    flatbuffers::Offset<AI> ai = 0,
    bool moving = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto log__ = log ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*log) : 0;
  auto goods__ = goods ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*goods) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<Property>>(*properties) : 0;
  auto stats__ = stats ? _fbb.CreateVector<uint32_t>(*stats) : 0;
  auto parts__ = parts ? _fbb.CreateVector<uint32_t>(*parts) : 0;
  auto equipment__ = equipment ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*equipment) : 0;
  return Save::CreateTraveler(
      _fbb,
      name__,
      toTown,
      fromTown,
      nation,
      log__,
      longitude,
      latitude,
      goods__,
      properties__,
      stats__,
      parts__,
      equipment__,
      ai,
      moving);
}

struct Business FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MODE = 6,
    VT_NAME = 8,
    VT_AREA = 10,
    VT_CANSWITCH = 12,
    VT_REQUIRECOAST = 14,
    VT_KEEPMATERIAL = 16,
    VT_REQUIREMENTS = 18,
    VT_RECLAIMABLES = 20,
    VT_INPUTS = 22,
    VT_OUTPUTS = 24,
    VT_FREQUENCY = 26,
    VT_RECLAIMFACTOR = 28
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t mode() const {
    return GetField<uint32_t>(VT_MODE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  double area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  bool canSwitch() const {
    return GetField<uint8_t>(VT_CANSWITCH, 0) != 0;
  }
  bool requireCoast() const {
    return GetField<uint8_t>(VT_REQUIRECOAST, 0) != 0;
  }
  bool keepMaterial() const {
    return GetField<uint8_t>(VT_KEEPMATERIAL, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *requirements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_REQUIREMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *reclaimables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_RECLAIMABLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_OUTPUTS);
  }
  double frequency() const {
    return GetField<double>(VT_FREQUENCY, 0.0);
  }
  double reclaimFactor() const {
    return GetField<double>(VT_RECLAIMFACTOR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<double>(verifier, VT_AREA) &&
           VerifyField<uint8_t>(verifier, VT_CANSWITCH) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRECOAST) &&
           VerifyField<uint8_t>(verifier, VT_KEEPMATERIAL) &&
           VerifyOffset(verifier, VT_REQUIREMENTS) &&
           verifier.VerifyVector(requirements()) &&
           verifier.VerifyVectorOfTables(requirements()) &&
           VerifyOffset(verifier, VT_RECLAIMABLES) &&
           verifier.VerifyVector(reclaimables()) &&
           verifier.VerifyVectorOfTables(reclaimables()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyField<double>(verifier, VT_FREQUENCY) &&
           VerifyField<double>(verifier, VT_RECLAIMFACTOR) &&
           verifier.EndTable();
  }
};

struct BusinessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Business::VT_ID, id, 0);
  }
  void add_mode(uint32_t mode) {
    fbb_.AddElement<uint32_t>(Business::VT_MODE, mode, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Business::VT_NAME, name);
  }
  void add_area(double area) {
    fbb_.AddElement<double>(Business::VT_AREA, area, 0.0);
  }
  void add_canSwitch(bool canSwitch) {
    fbb_.AddElement<uint8_t>(Business::VT_CANSWITCH, static_cast<uint8_t>(canSwitch), 0);
  }
  void add_requireCoast(bool requireCoast) {
    fbb_.AddElement<uint8_t>(Business::VT_REQUIRECOAST, static_cast<uint8_t>(requireCoast), 0);
  }
  void add_keepMaterial(bool keepMaterial) {
    fbb_.AddElement<uint8_t>(Business::VT_KEEPMATERIAL, static_cast<uint8_t>(keepMaterial), 0);
  }
  void add_requirements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> requirements) {
    fbb_.AddOffset(Business::VT_REQUIREMENTS, requirements);
  }
  void add_reclaimables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> reclaimables) {
    fbb_.AddOffset(Business::VT_RECLAIMABLES, reclaimables);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> inputs) {
    fbb_.AddOffset(Business::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> outputs) {
    fbb_.AddOffset(Business::VT_OUTPUTS, outputs);
  }
  void add_frequency(double frequency) {
    fbb_.AddElement<double>(Business::VT_FREQUENCY, frequency, 0.0);
  }
  void add_reclaimFactor(double reclaimFactor) {
    fbb_.AddElement<double>(Business::VT_RECLAIMFACTOR, reclaimFactor, 0.0);
  }
  explicit BusinessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BusinessBuilder &operator=(const BusinessBuilder &);
  flatbuffers::Offset<Business> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Business>(end);
    return o;
  }
};

inline flatbuffers::Offset<Business> CreateBusiness(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mode = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double area = 0.0,
    bool canSwitch = false,
    bool requireCoast = false,
    bool keepMaterial = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> requirements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> reclaimables = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> outputs = 0,
    double frequency = 0.0,
    double reclaimFactor = 0.0) {
  BusinessBuilder builder_(_fbb);
  builder_.add_reclaimFactor(reclaimFactor);
  builder_.add_frequency(frequency);
  builder_.add_area(area);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_reclaimables(reclaimables);
  builder_.add_requirements(requirements);
  builder_.add_name(name);
  builder_.add_mode(mode);
  builder_.add_id(id);
  builder_.add_keepMaterial(keepMaterial);
  builder_.add_requireCoast(requireCoast);
  builder_.add_canSwitch(canSwitch);
  return builder_.Finish();
}

inline flatbuffers::Offset<Business> CreateBusinessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mode = 0,
    const char *name = nullptr,
    double area = 0.0,
    bool canSwitch = false,
    bool requireCoast = false,
    bool keepMaterial = false,
    const std::vector<flatbuffers::Offset<Good>> *requirements = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *reclaimables = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *outputs = nullptr,
    double frequency = 0.0,
    double reclaimFactor = 0.0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto requirements__ = requirements ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*requirements) : 0;
  auto reclaimables__ = reclaimables ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*reclaimables) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*outputs) : 0;
  return Save::CreateBusiness(
      _fbb,
      id,
      mode,
      name__,
      area,
      canSwitch,
      requireCoast,
      keepMaterial,
      requirements__,
      reclaimables__,
      inputs__,
      outputs__,
      frequency,
      reclaimFactor);
}

struct Town FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAMES = 6,
    VT_NATION = 8,
    VT_LONGITUDE = 10,
    VT_LATITUDE = 12,
    VT_COASTAL = 14,
    VT_POPULATION = 16,
    VT_TOWNTYPE = 18,
    VT_BUSINESSES = 20,
    VT_GOODS = 22,
    VT_NEIGHBORS = 24,
    VT_BUSINESSCOUNTER = 26
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  uint32_t nation() const {
    return GetField<uint32_t>(VT_NATION, 0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  bool coastal() const {
    return GetField<uint8_t>(VT_COASTAL, 0) != 0;
  }
  uint64_t population() const {
    return GetField<uint64_t>(VT_POPULATION, 0);
  }
  uint32_t townType() const {
    return GetField<uint32_t>(VT_TOWNTYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Business>> *businesses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Business>> *>(VT_BUSINESSES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *goods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_GOODS);
  }
  const flatbuffers::Vector<uint32_t> *neighbors() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NEIGHBORS);
  }
  int32_t businessCounter() const {
    return GetField<int32_t>(VT_BUSINESSCOUNTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyField<uint32_t>(verifier, VT_NATION) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<uint8_t>(verifier, VT_COASTAL) &&
           VerifyField<uint64_t>(verifier, VT_POPULATION) &&
           VerifyField<uint32_t>(verifier, VT_TOWNTYPE) &&
           VerifyOffset(verifier, VT_BUSINESSES) &&
           verifier.VerifyVector(businesses()) &&
           verifier.VerifyVectorOfTables(businesses()) &&
           VerifyOffset(verifier, VT_GOODS) &&
           verifier.VerifyVector(goods()) &&
           verifier.VerifyVectorOfTables(goods()) &&
           VerifyOffset(verifier, VT_NEIGHBORS) &&
           verifier.VerifyVector(neighbors()) &&
           VerifyField<int32_t>(verifier, VT_BUSINESSCOUNTER) &&
           verifier.EndTable();
  }
};

struct TownBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Town::VT_ID, id, 0);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(Town::VT_NAMES, names);
  }
  void add_nation(uint32_t nation) {
    fbb_.AddElement<uint32_t>(Town::VT_NATION, nation, 0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(Town::VT_LONGITUDE, longitude, 0.0);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(Town::VT_LATITUDE, latitude, 0.0);
  }
  void add_coastal(bool coastal) {
    fbb_.AddElement<uint8_t>(Town::VT_COASTAL, static_cast<uint8_t>(coastal), 0);
  }
  void add_population(uint64_t population) {
    fbb_.AddElement<uint64_t>(Town::VT_POPULATION, population, 0);
  }
  void add_townType(uint32_t townType) {
    fbb_.AddElement<uint32_t>(Town::VT_TOWNTYPE, townType, 0);
  }
  void add_businesses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses) {
    fbb_.AddOffset(Town::VT_BUSINESSES, businesses);
  }
  void add_goods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods) {
    fbb_.AddOffset(Town::VT_GOODS, goods);
  }
  void add_neighbors(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> neighbors) {
    fbb_.AddOffset(Town::VT_NEIGHBORS, neighbors);
  }
  void add_businessCounter(int32_t businessCounter) {
    fbb_.AddElement<int32_t>(Town::VT_BUSINESSCOUNTER, businessCounter, 0);
  }
  explicit TownBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TownBuilder &operator=(const TownBuilder &);
  flatbuffers::Offset<Town> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Town>(end);
    return o;
  }
};

inline flatbuffers::Offset<Town> CreateTown(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    uint32_t nation = 0,
    double longitude = 0.0,
    double latitude = 0.0,
    bool coastal = false,
    uint64_t population = 0,
    uint32_t townType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> neighbors = 0,
    int32_t businessCounter = 0) {
  TownBuilder builder_(_fbb);
  builder_.add_population(population);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  builder_.add_businessCounter(businessCounter);
  builder_.add_neighbors(neighbors);
  builder_.add_goods(goods);
  builder_.add_businesses(businesses);
  builder_.add_townType(townType);
  builder_.add_nation(nation);
  builder_.add_names(names);
  builder_.add_id(id);
  builder_.add_coastal(coastal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Town> CreateTownDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    uint32_t nation = 0,
    double longitude = 0.0,
    double latitude = 0.0,
    bool coastal = false,
    uint64_t population = 0,
    uint32_t townType = 0,
    const std::vector<flatbuffers::Offset<Business>> *businesses = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *goods = nullptr,
    const std::vector<uint32_t> *neighbors = nullptr,
    int32_t businessCounter = 0) {
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  auto businesses__ = businesses ? _fbb.CreateVector<flatbuffers::Offset<Business>>(*businesses) : 0;
  auto goods__ = goods ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*goods) : 0;
  auto neighbors__ = neighbors ? _fbb.CreateVector<uint32_t>(*neighbors) : 0;
  return Save::CreateTown(
      _fbb,
      id,
      names__,
      nation,
      longitude,
      latitude,
      coastal,
      population,
      townType,
      businesses__,
      goods__,
      neighbors__,
      businessCounter);
}

struct Nation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAMES = 6,
    VT_ADJECTIVE = 8,
    VT_FOREGROUND = 10,
    VT_BACKGROUND = 12,
    VT_RELIGION = 14,
    VT_TRAVELERNAMES = 16,
    VT_GOODS = 18,
    VT_BUSINESSES = 20
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  const flatbuffers::String *adjective() const {
    return GetPointer<const flatbuffers::String *>(VT_ADJECTIVE);
  }
  const Color *foreground() const {
    return GetStruct<const Color *>(VT_FOREGROUND);
  }
  const Color *background() const {
    return GetStruct<const Color *>(VT_BACKGROUND);
  }
  const flatbuffers::String *religion() const {
    return GetPointer<const flatbuffers::String *>(VT_RELIGION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *travelerNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TRAVELERNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Good>> *goods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Good>> *>(VT_GOODS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Business>> *businesses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Business>> *>(VT_BUSINESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_ADJECTIVE) &&
           verifier.VerifyString(adjective()) &&
           VerifyField<Color>(verifier, VT_FOREGROUND) &&
           VerifyField<Color>(verifier, VT_BACKGROUND) &&
           VerifyOffset(verifier, VT_RELIGION) &&
           verifier.VerifyString(religion()) &&
           VerifyOffset(verifier, VT_TRAVELERNAMES) &&
           verifier.VerifyVector(travelerNames()) &&
           verifier.VerifyVectorOfStrings(travelerNames()) &&
           VerifyOffset(verifier, VT_GOODS) &&
           verifier.VerifyVector(goods()) &&
           verifier.VerifyVectorOfTables(goods()) &&
           VerifyOffset(verifier, VT_BUSINESSES) &&
           verifier.VerifyVector(businesses()) &&
           verifier.VerifyVectorOfTables(businesses()) &&
           verifier.EndTable();
  }
};

struct NationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Nation::VT_ID, id, 0);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(Nation::VT_NAMES, names);
  }
  void add_adjective(flatbuffers::Offset<flatbuffers::String> adjective) {
    fbb_.AddOffset(Nation::VT_ADJECTIVE, adjective);
  }
  void add_foreground(const Color *foreground) {
    fbb_.AddStruct(Nation::VT_FOREGROUND, foreground);
  }
  void add_background(const Color *background) {
    fbb_.AddStruct(Nation::VT_BACKGROUND, background);
  }
  void add_religion(flatbuffers::Offset<flatbuffers::String> religion) {
    fbb_.AddOffset(Nation::VT_RELIGION, religion);
  }
  void add_travelerNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> travelerNames) {
    fbb_.AddOffset(Nation::VT_TRAVELERNAMES, travelerNames);
  }
  void add_goods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods) {
    fbb_.AddOffset(Nation::VT_GOODS, goods);
  }
  void add_businesses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses) {
    fbb_.AddOffset(Nation::VT_BUSINESSES, businesses);
  }
  explicit NationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NationBuilder &operator=(const NationBuilder &);
  flatbuffers::Offset<Nation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nation> CreateNation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    flatbuffers::Offset<flatbuffers::String> adjective = 0,
    const Color *foreground = 0,
    const Color *background = 0,
    flatbuffers::Offset<flatbuffers::String> religion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> travelerNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Good>>> goods = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Business>>> businesses = 0) {
  NationBuilder builder_(_fbb);
  builder_.add_businesses(businesses);
  builder_.add_goods(goods);
  builder_.add_travelerNames(travelerNames);
  builder_.add_religion(religion);
  builder_.add_background(background);
  builder_.add_foreground(foreground);
  builder_.add_adjective(adjective);
  builder_.add_names(names);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Nation> CreateNationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    const char *adjective = nullptr,
    const Color *foreground = 0,
    const Color *background = 0,
    const char *religion = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *travelerNames = nullptr,
    const std::vector<flatbuffers::Offset<Good>> *goods = nullptr,
    const std::vector<flatbuffers::Offset<Business>> *businesses = nullptr) {
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  auto adjective__ = adjective ? _fbb.CreateString(adjective) : 0;
  auto religion__ = religion ? _fbb.CreateString(religion) : 0;
  auto travelerNames__ = travelerNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*travelerNames) : 0;
  auto goods__ = goods ? _fbb.CreateVector<flatbuffers::Offset<Good>>(*goods) : 0;
  auto businesses__ = businesses ? _fbb.CreateVector<flatbuffers::Offset<Business>>(*businesses) : 0;
  return Save::CreateNation(
      _fbb,
      id,
      names__,
      adjective__,
      foreground,
      background,
      religion__,
      travelerNames__,
      goods__,
      businesses__);
}

struct Game FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOWNS = 4,
    VT_PLAYERTRAVELER = 6,
    VT_AITRAVELERS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Town>> *towns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Town>> *>(VT_TOWNS);
  }
  const Traveler *playerTraveler() const {
    return GetPointer<const Traveler *>(VT_PLAYERTRAVELER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Traveler>> *aITravelers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Traveler>> *>(VT_AITRAVELERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOWNS) &&
           verifier.VerifyVector(towns()) &&
           verifier.VerifyVectorOfTables(towns()) &&
           VerifyOffset(verifier, VT_PLAYERTRAVELER) &&
           verifier.VerifyTable(playerTraveler()) &&
           VerifyOffset(verifier, VT_AITRAVELERS) &&
           verifier.VerifyVector(aITravelers()) &&
           verifier.VerifyVectorOfTables(aITravelers()) &&
           verifier.EndTable();
  }
};

struct GameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_towns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Town>>> towns) {
    fbb_.AddOffset(Game::VT_TOWNS, towns);
  }
  void add_playerTraveler(flatbuffers::Offset<Traveler> playerTraveler) {
    fbb_.AddOffset(Game::VT_PLAYERTRAVELER, playerTraveler);
  }
  void add_aITravelers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Traveler>>> aITravelers) {
    fbb_.AddOffset(Game::VT_AITRAVELERS, aITravelers);
  }
  explicit GameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameBuilder &operator=(const GameBuilder &);
  flatbuffers::Offset<Game> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Game>(end);
    return o;
  }
};

inline flatbuffers::Offset<Game> CreateGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Town>>> towns = 0,
    flatbuffers::Offset<Traveler> playerTraveler = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Traveler>>> aITravelers = 0) {
  GameBuilder builder_(_fbb);
  builder_.add_aITravelers(aITravelers);
  builder_.add_playerTraveler(playerTraveler);
  builder_.add_towns(towns);
  return builder_.Finish();
}

inline flatbuffers::Offset<Game> CreateGameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Town>> *towns = nullptr,
    flatbuffers::Offset<Traveler> playerTraveler = 0,
    const std::vector<flatbuffers::Offset<Traveler>> *aITravelers = nullptr) {
  auto towns__ = towns ? _fbb.CreateVector<flatbuffers::Offset<Town>>(*towns) : 0;
  auto aITravelers__ = aITravelers ? _fbb.CreateVector<flatbuffers::Offset<Traveler>>(*aITravelers) : 0;
  return Save::CreateGame(
      _fbb,
      towns__,
      playerTraveler,
      aITravelers__);
}

inline const Save::Game *GetGame(const void *buf) {
  return flatbuffers::GetRoot<Save::Game>(buf);
}

inline const Save::Game *GetSizePrefixedGame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Save::Game>(buf);
}

inline bool VerifyGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Save::Game>(nullptr);
}

inline bool VerifySizePrefixedGameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Save::Game>(nullptr);
}

inline void FinishGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Save::Game> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Save::Game> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Save

#endif  // FLATBUFFERS_GENERATED_SAVE_SAVE_H_
